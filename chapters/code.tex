\chapter{Description of custom software}
This appendix provides a description of the custom software written as a part of this project.

\section{OxCal Results Extractor}
The version of this software used can be found at \citet{doug_cowie_2019_2555393}. This is a javascript tool for extracting the results from OxCal v4 raw files. The raw output files from OxCal v4 encode the data in an executable javascript format, i.e. rather than a traditional data file, the objects containing the data are only accessible once the output file has been run through a javascript interpreter.

There are three crucial data structures: ocd the OxCal data, calib the calibration data, and model that contains a version of the bayesian model. To extract values from the modelled dates, the posterior data structure is accessed for each record in the ocd structure. Each ocd record represents a sample in the OxCal model. To extract the mean values for each sample modelled by OxCal the ocd structure is iterated through and the posterior.mean value stored in an output data format. The same operation is repeated to obtain the median values, but using posterior.median.

Also in this project is a utility for generating weights for use with ArcGIS autocorrelation tools, including an encoded format of the Hambledon Hill model. This tool outputs weights such that dates in phase are given a weight of '1' and those in sequence are inverse to their distance in the sequence.

\section{Tools for working with Euroevol dataset}
\citet{doug_cowie_2018_1297321} is a collection of utilities written in Typescript for analysing the EUROEVOL data set \citep{Manning:2016fk}. The calib-extract module is designed to load in an OxCal v4 raw output file stored in the /data/ directory. The raw ocd data structure is parsed to create a hash map of dated samples with the mean values from their calibrated distribution as determined by OxCal. This hash map data structure is then converted into a JSON object, which is the input format required by the json2csv module. A CSV format of the hash map of sample ID to mean calibrated date is written out as a CSV file.

This file has been designed such that by using the IDs it can be combined with the original EUROEVOL date table, so that each date is now augmented with the mean of it's calibrated distribution.

Such a combined file is the input for the main module, although before it can be used with this module it should be processed by a GIS and each row augment with the ID for the cell in a grid that corresponds to the location the dated sample was found in. Provided such an input, the main module will process the input file to create an output CSV file that contains only a list of cell IDs and the corresponding earliest Neolithic date from the cell. Cells without any Neolithic dates are not included in the output. 

The main part of this processing is performed in the calculateFirstNeolithic method, where the input list of each date is reduced down to a Map of cell ID to date value. For each row the mean calibrated date and the cell ID are extracted, the period code for the row is then assessed to make sure that the date is from any post-Mesolithic prehistoric phase. If the map already contains a value for this cell, it is compared to the new date and if the new value is less (as B.C. dates are stored as negatives) the cell IDs value in the map is replaced by the new date. If there is no value stored for this cell ID already, the current value is assigned to it.

\section{Cellular Automata Model}
\citet{doug_cowie_2018_1297319} is a Typescript implementation of a minimal cellular automata model. The program starts by defining some static values: the state each cell may be in, either susceptible or infected and the list of the eight neighbours a cell can have taken from their compass bearings as they relate to a particular cell. There is then the definition of a cell as a data type, each cell will have an id, a value (i.e. a state), an x and a y co-ordinate. 

Following this is a definition of a series of functions that define the behaviour of the model, they are loosely grouped by capability, with the first set defining direct transmission. The function doMove handles the direct spread or movement of infection from one cell to one or more of its eight adjoining cells. For each neighbour there is an independent random number generated, if the number is less than 0.3 (numbers will be in the range 0 to 1) this indicates movement from the cell into that particular neighbour. This gives a 30\% probability there will be a move for each neighbour. The next function, neighbourCoords determines the co-ordinates of a neighbour, given a source cell and the neighbours direction. The movementPhase function performs the doMove function on each cell. The function ensures that the original data structure that represents the model world is not modified and the updated state is recorded in a new data structure. This ensures no double moves, where a cell that was infected in this phase infects one of it's neighbours.

The next set of functions model the indirect transmission behaviour, also referred to as leap frogging. This is where Neolithic culture spreads (or appears to spread) over longer distances missing out intermediate areas. The model makes no assumptions about the cause of this, it could be down to the mechanism of spread, or gaps in the data set being replicated. The first function here, calculateNoInfectedNeighbours uses a 3rd party library to calculated an extended moore neighbourhood of n degrees in two dimensions, this is then translated into relative grid co-ordinates to the target cell. The function then determines how many of a cells neighbours the Neolithic has spread to already within the defined neighbourhood. The next function infectionIndex calculates a metric of the same name for a particular cell for a given size of extended moore neighbourhood. The metric takes the number of cells that the Neolithic has spread to and weights them inversely to their distance from the target cell. Distance is based on the extended moore neighbourhood they first fall into. The doInfection function takes an infectionIndex using 10 degrees of neighbour for a specific cell, randomly calculates a threshold between 0 and 100, if the index is greater than the threshold it returns true to indicate that the Neolithic has spread to that cell. The infectionPhase function iterates over all the cells in the model and runs the doInfection function on those which are still susceptible. As with the movementPhase, the original cell data structure is not update, instead a list of cells whose state has been modified is returned.

The final set of functions are those which do not model specific behaviours as such, but are other essential components of the model. The cellPhase function runs both the movementPhase and infectionPhase, creating a list of cells whose state is to be updated following this phase of the model. It also calls updateState to perform this update and returns the list of modified cells. The createWorld function creates and initialises a data structure of specified size that holds all the cells in a grid for a run of the model. The cells are initialised to a provided state. The seed function contains a hard coded list of cells to initialise to already have had the Neolithic spread to them at the start of the model, the cells were determined by examining the EUROEVOL data set to find those cells that have the earliest recorded Neolithic dates. The convertToGrid function transforms the data structure representing the model into an array of javascript objects, which can be conveniently turned into a csv file using a 3rd party library. Each object contains its ID, a state value, an x and a y co-ordinate. The updateState function uses a list of provided cell co-ordinates to update the state of those cells in the data structure representing the model. 

Finally, the runModel function creates a specific instance of the model data structure, referred to as theWorld, and a similar structure called outputWorld used to record which phase of the model run the Neolithic spread to each cell. Both of these structures are then set to the model start state using the seed function. The model is then run through a number of phases provided as input to the runModel function, after each cellPhase has been run the list of updated cells is used to update the outputWorld data structure, taking the phase number as the value for each cell updated in this phase. Once the final phase has been run the outputWorld is converted to a grid format, which is then output to a csv file. When the file is executed the runModel function is called to run through 10 phases.

The csv file can then be imported into a GIS and related to a grid layer using the x and y fields of the file. 